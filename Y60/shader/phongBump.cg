// blinn-phong shading using normal maps

struct a2v {
float4 Position : POSITION; //in object space 
float3 Normal : NORMAL; //in object space 
float2 TexCoord : TEXCOORD0;
}; 

struct v2f {
float4 Position : POSITION; //in projection space 
float3 TexCoord0 : TEXCOORD0;
float3 LightDirection : TEXCOORD1; //in tangent space 
float3 HalfAngleVector : TEXCOORD2; //in tangent space
}; 


float3 compress(float3 v) {
    return 0.5 * v + 0.5;
}

float3 expand(float3 v) {
    return 2.0 * (v - 0.5);
}

float4 compress(float4 v) {
    return 0.5 * v + 0.5;
}

float4 expand(float4 v) {
    return 2.0 * (v - 0.5);
}

v2f mainVertex(a2v IN,
        uniform float4x4 GL_MODELVIEW_PROJECTION,
        uniform float4 lightPosition, //in object space 
        uniform float4 eyePosition ) //in object space 
{ 
    v2f OUT; // pass texture coordinates for
    OUT.Position = mul(GL_MODELVIEW_PROJECTION, IN.Position);
    OUT.TexCoord0.xy = IN.TexCoord.xy;
    OUT.LightDirection.xyz = normalize(lightPosition - IN.Position);
    float3 viewVector = normalize(eyePosition.xyz - IN.Position.xyz);
    OUT.HalfAngleVector.xyz = normalize(OUT.LightDirection.xyz + viewVector);
    return OUT;
}

float4 mainFragment(v2f IN,
                    uniform sampler2D ground,
                    uniform sampler2D normalMap,
                    uniform float4 ambient,
                    uniform float4 diffuse,
                    uniform float4 specular,
                    uniform float shininess
                    ) : COLOR
{ 
    float4 myGroundColor = tex2D(ground, IN.TexCoord0).rgba;
    float3 myNormal = normalize(tex2D(normalMap, IN.TexCoord0).xyz);

    float3 myAmbient = ambient.xyz;

    float diffuseLight = max(dot(myNormal, IN.LightDirection),0);
    float3 myDiffuse = diffuse.xyz * diffuseLight;

    float specularLight = pow(max(dot(myNormal, expand(IN.HalfAngleVector)),0), shininess);

    if (diffuseLight <= 0) specularLight = 0;
    float3 mySpecular = specular.xyz * specularLight;

    float4 color;
    color.xyz = (myAmbient + myDiffuse + mySpecular) * myGroundColor;
    color.w = 1;
    return color;
}

