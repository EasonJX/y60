#include "Capture.h"
#include <asl/Logger.h>
#include "CaptureDevice.h"
#include <y60/DecoderManager.h>

using namespace dom;
using namespace std;

namespace y60 {

    Capture::Capture(dom::Node & theNode) : Image(theNode),
        FrameRateTag::Plug(theNode),
        PlayModeTag::Plug(theNode),
        DeviceTag::Plug(theNode),
        NormTag::Plug(theNode), _myDevice(0),
        _myPlayMode(PLAY_MODE_STOP)
    {
        AC_TRACE << "Capture::Capture " << theNode;
    }

    Capture::~Capture() {
    }

    void Capture::stop() {
        AC_INFO << "Capture::stop";
        _myDevice->stopCapture();
        set<PlayModeTag>(asl::getStringFromEnum(PLAY_MODE_STOP, MoviePlayModeStrings));
        dom::ResizeableRasterPtr myRaster = getRasterPtr();
        memset(myRaster->pixels().begin(), 0, myRaster->pixels().size());
    }

    void
    Capture::setPlayMode(MoviePlayMode thePlayMode) {
        AC_DEBUG << "Capture::setPlayMode " << asl::getStringFromEnum(thePlayMode, MoviePlayModeStrings);
        // process changes
        switch (thePlayMode) {
            case PLAY_MODE_STOP:
                stop();
                break;
            case PLAY_MODE_PLAY:
                _myDevice->startCapture();
                break;
            case PLAY_MODE_PAUSE:
                if (_myPlayMode == PLAY_MODE_STOP) {
                    _myDevice->startCapture();
                }
                _myDevice->pauseCapture();
                break;
        }

        // Synchronize internal and external representation
        _myPlayMode = thePlayMode;
        set<PlayModeTag>(asl::getStringFromEnum(thePlayMode, MoviePlayModeStrings));
    }

    void
    Capture::readFrame() {
        if (!_myDevice) {
            AC_ERROR << "Capture::readFrame not allowed before open";
            return;
        }
        // Check for playmode changes from javascript
        MoviePlayMode myPlayMode = MoviePlayMode(asl::getEnumFromString(get<PlayModeTag>(), MoviePlayModeStrings));
        if (myPlayMode != _myPlayMode) {
            setPlayMode(myPlayMode);
        }
        _myDevice->readFrame(getRasterPtr());
    }

    void Capture::load(asl::PackageManager & thePackageManager) {

        const std::string & mySourceFile = get<ImageSourceTag>();
        AC_DEBUG << "Capture::load " << mySourceFile;
        open(mySourceFile);
    }

    void
    Capture::load(const std::string & theTexturePath) {
        const std::string & mySourceFile = get<ImageSourceTag>();
        open(mySourceFile);
    }

    void
    Capture::open(const std::string & theUrl) {
        if (_myDevice) {
            _myDevice = CaptureDevicePtr(0);
        }

        AC_DEBUG << "Capture::open " << (void*)this << " url=" << theUrl;

        // First: Look for registered decoders that could handle the source
        CaptureDevicePtr myDevice = DecoderManager::get().findDecoder<CaptureDevice>(theUrl);

        if (!myDevice) {
            AC_ERROR << "Capture::open(): could not load capture device!";
            return;
        }
        _myDevice = myDevice->instance();

        _myDevice->initialize(this);
        dom::ValuePtr myRasterValue = getRasterValue();
        if (!myRasterValue) {
            // Create default raster
            createRaster(1,1,1,GRAY);
        }
        _myDevice->load(theUrl);

        /*
         * UH: theUrl is mangled by the PackageManager and is not necessarily the same as the ImageSourceTag
         * this leads to multiple load() calls by the TextureManager since reloadRequired checks
         * _myLoadedFilename against ImageSourceTag and finds them to differ.
         */
        _myLoadedFilename = get<ImageSourceTag>(); // theUrl;

        Image::createRaster(get<ImageWidthTag>(), get<ImageHeightTag>(), 1, getRasterEncoding());

        if (_myPlayMode == PLAY_MODE_PLAY) {
            _myDevice->startCapture();
        }
    }

    bool
    Capture::reloadRequired() const {
        return (!_myDevice || _myLoadedFilename != get<ImageSourceTag>());
    }
}
