//=============================================================================
// Copyright (C) 2003 ART+COM AG Berlin
//
// These coded instructions, statements, and computer programs contain
// unpublished proprietary information of ART+COM AG Berlin, and
// are copy protected by law. They may not be disclosed to third parties
// or copied or duplicated in any form, in whole or in part, without the
// specific, prior written permission of ART+COM AG Berlin.
//=============================================================================
//
//   $RCSfile: wave_2d.cg,v $
//   $Author: valentin $
//   $Revision: 1.7 $
//   $Date: 2004/08/25 11:28:17 $
//
//  Description: 
//=============================================================================

float3 get_normal_from_heightfield(float2 theTexCoords, uniform sampler2D heightfield, float2 theTexSize) {
    float s = theTexCoords.s;
    float t = theTexCoords.t;
    float ds = 1.0/theTexSize.x;
    float dt = 1.0/theTexSize.y;

    float scale = 1;

    float h = scale * tex2D( heightfield, float2(s,t) ).y;

    float h_l = scale *tex2D( heightfield, float2(s - ds, t)).y;
    
    float h_r = scale *tex2D( heightfield, float2(s + ds, t)).y;

    float h_t = scale *tex2D( heightfield, float2(s , t + dt)).y;

    float h_b = scale *tex2D( heightfield, float2(s, t - dt )).y;

    float3 n0 = normalize(float3( h_l - h, 1.0, h_t - h ));
    float3 n1 = normalize(float3( h - h_r, 1.0, h_t - h ));
    float3 n2 = normalize(float3( h - h_r, 1.0, h - h_b ));
    float3 n3 = normalize(float3( h_l - h, 1.0, h - h_b ));
    
    //return (n0 + n1 + n2 + n3) * 0.01;
    float3 myNormal =  normalize( (n0 + n1 + n2 + n3) *0.25);
    //myNormal.x *= ds;
    //myNormal.z *= dt;
    myNormal.x /= theTexSize.x/20;
    myNormal.z /= theTexSize.y/20;
    return myNormal;
    //return normalize( (n0 + n1 + n2 + n3) * 0.25);
}

struct app2vert { 
    float4 Position : POSITION;
    float3 Normal   : NORMAL;
    float4 Center   : COLOR0;
    float2 TexCoord : TEXCOORD0;
};

struct vert2frag {
    float4 Vertex    : POSITION;
    float2 TexCoord  : TEXCOORD0;
};

vert2frag mainVertex(app2vert IN,    
                     uniform float4x4 GL_MODELVIEW_PROJECTION)
{
    vert2frag OUT;

    OUT.Vertex = mul(GL_MODELVIEW_PROJECTION, IN.Position);
    OUT.TexCoord.x = IN.TexCoord.x;
    // we need to flip texture coords in y direction, cause texture 'floor' is generated by offscreenrendering, so it is y-flipped!
    OUT.TexCoord.y = 1.0-IN.TexCoord.y;

    return OUT;
}


float4 mainFragment(vert2frag IN,
                    uniform sampler2D floor,
                    uniform sampler2D surface,
                    uniform float2 theTexSize): COLOR
{
    
    float3 myNormal = get_normal_from_heightfield(IN.TexCoord, surface, theTexSize);
    float4 textureColor = tex2D(floor, IN.TexCoord + myNormal.xz);
    return textureColor;
}
