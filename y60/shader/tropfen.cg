//=============================================================================
// Copyright (C) 2003 ART+COM AG Berlin
//
// These coded instructions, statements, and computer programs contain
// unpublished proprietary information of ART+COM AG Berlin, and
// are copy protected by law. They may not be disclosed to third parties
// or copied or duplicated in any form, in whole or in part, without the
// specific, prior written permission of ART+COM AG Berlin.
//=============================================================================
//
//   $RCSfile: wave_2d.cg,v $
//   $Author: valentin $
//   $Revision: 1.7 $
//   $Date: 2004/08/25 11:28:17 $
//
//  Description: 
//=============================================================================

#include "glow_utils.cg"

struct app2vert { 
    float4 Position : POSITION;
    float3 Normal   : NORMAL;
    float2 TexCoord : TEXCOORD0;
};

struct vert2frag {
    float4 Vertex    : POSITION;
    float2 TexCoord0 : TEXCOORD0;
    float2 TexCoord1 : TEXCOORD1;
    float2 TexCoordC : TEXCOORD2;
    bool TwoTexFlag;
};

vert2frag mainVertex(app2vert IN,    
                     uniform float4x4 GL_MODELVIEW_PROJECTION,
                     uniform float4x4 AC_TEXTURE_MATRICES[])
{
    vert2frag OUT;

    OUT.Vertex = mul(GL_MODELVIEW_PROJECTION, IN.Position);
    OUT.TexCoord0 = mul(AC_TEXTURE_MATRICES[0], float4(IN.TexCoord,0,1)).xy;
    OUT.TexCoord1 = float2(0,0);
    OUT.TwoTexFlag = false;
    if(AC_TEXTURE_MATRICES.length == 2) {
        OUT.TexCoord1 = mul(AC_TEXTURE_MATRICES[1], float4(IN.TexCoord,0,1)).xy;
        OUT.TwoTexFlag = true;
    }
    OUT.TexCoordC = IN.TexCoord;
    return OUT;
}


float4 mainFragment2Tex(vert2frag IN,
                    uniform sampler2D tex0,
                    uniform sampler2D tex1,
                    uniform float radius,
                    uniform float4 surfacecolor): COLOR
{
    float4 textureColor0 = tex2D(tex0, IN.TexCoord0);
    float center_distance =  length(IN.TexCoordC.st - 0.5 );
    float4 textureColor1 = float4(0,0,0,0);
    if(IN.TwoTexFlag == true) {    
        textureColor1 = tex2D(tex1, IN.TexCoord1);
    }
    
    if (center_distance > radius) {
        return float4(0,0,0,0);
    } else {
        float3 myTextureColor0 = textureColor0.rgb * textureColor0.a;
        float3 myTextureColor1 = textureColor1.rgb * textureColor1.a;
        float3 myResultColor = myTextureColor1 + myTextureColor0;
        float  mySumAlpha = textureColor0.a + textureColor1.a;
    
        return float4(myResultColor.rgb/float3(mySumAlpha), mySumAlpha)*surfacecolor;
    }
}

float4 mainFragment(vert2frag IN,
                    uniform sampler2D tex0,
                    uniform float radius,
                    uniform float4 surfacecolor): COLOR
{
    float4 textureColor0 = tex2D(tex0, IN.TexCoord0);
    float center_distance =  length(IN.TexCoordC.st - 0.5 );
    
    if (center_distance > radius) {
        return float4(0,0,0,0);
    } else {
        return textureColor0 * surfacecolor;
    }
}

// Textglow including Textblur Fragment Shader
float4 mainFragmentGlowBlurTropfen(vert2frag IN,
                    uniform sampler2D tex0,
                    uniform float width,
                    uniform float height,
                    uniform float blur,
                    uniform float glow_radius,
                    uniform float radius,
                    uniform float4 surfacecolor,
                    uniform float4 glow_color,
                    uniform float2 offset) : COLOR
{    
    float4 textureColor0 = tex2D(tex0, IN.TexCoord0);
    float center_distance =  length(IN.TexCoordC.st - 0.5 );
    
    if (center_distance > radius) {
        return float4(0,0,0,0);
    } else {
        float4 myGlow = float4(0.0);
        float4 myText = float4(0.0);
        
        float pixW = 1.0/width;
        float pixH = 1.0/height;
        
        if (blur > 0.0) {
            myText = applyGauss(tex0, IN.TexCoord0.xy, blur, pixW, pixH);
        } else {
            myText = tex2D(tex0, float2(IN.TexCoord0.xy));
        }
    
        if (glow_radius != 0.0) {
            myGlow = float4(glow_color.rgb, applyGauss(tex0, IN.TexCoord0.xy-(offset*float2(pixW, pixH)), 
                                             glow_radius + blur, pixW, pixH).a);
            myGlow.a *= glow_color.a;
        }
        return calculateTextGlow(myGlow, myText) * surfacecolor;
    }

    
}

