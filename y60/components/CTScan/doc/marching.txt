Marching Cubes
==============


1. Einleitung
-------------

Lutz


2. Beschreibung des Papers
--------------------------

Lutz


3. Optimierungsans\*atze des Papers
-----------------------------------

Lutz


4. Anforderungen an die Implementierung
---------------------------------------

Der Marching Cubes Algorithmus soll aufgrund der besseren
Wiederverwertbarkeit in C++ implementiert werden. Es ist die bereits
vorhandene Daten-Klasse 'vmData' zum Einlesen der 3D-Daten zu
verwenden.  Das Programm mu\*s auch lokal anwendbar sein. Es soll also
nicht immer der gesamte Datensatz "gemarched" werden, sondern auch ein,
mittels einer 3D-Box zu selektierender Bereich, bearbeitet werden.

Au\*serdem sind die Entscheidung, ob ein Wert innen oder au\*sen liegt
und die Interpolation so zu implementieren, da\*s sie leicht durch
andere Routinen ausgetauscht werden k\*onnen.


5. Unsere Implementierung
-------------------------

5.1 Zielsetzung und Entwurf

Ziel unseres Entwurfes ist es im Rahmen der Anforderungen eine
m\*oglichst korrekte (l\*ocherfrei) und effiziente Implementierung
sowohl im Hinblick auf Speicherbedarf als auch auf Performance zu
leisten. DIes schlie\*st eine rekursive Implentierung aus, weil
hierf\*ur mehr Daten im Speicher gehalten werden m\*ussen und auch das
Caching der bereits berechneten Daten ist wesentlich aufwendiger. Bei
einem iterativen Ansatz ist weder das Caching noch die Datenmenge im
Speicher ein Problem, da der Algorithmus immer nur die Werte des
aktuellen Voxels ben\*otigt.

Um keine Berechnung doppelt ausf\*uhren zu m\*ssen, haben wir uns einen
speziellen Caching-Mechanismus ausgedacht. Er zieht in allen drei
Ebenen x-y-z einen Slice der zuletzt berechneten Werte hinterher und
berechnet jeweils nur die vordersten Schnittpunkte der drei Ebenen neu.
Im Speicher sind also im wesentlichen nur die beiden Slices zur Bildung
der Voxelschicht plus drei Caching-Slices. Mit dieser Methode ist es
auch m\*oglich datens\*atze zu bearbeiten, die in ihrer Dimension den
Hauptspeicher um ein Vielfaches \*ubersteigen ohne dabei
Effizienzeinbu\*sen in Kauf nehmen zu m\*ussen.

Wir haben uns daf\*ur entschieden den Marching Cubes Algorithmus in
eine C++ Klasse zu stecken, da es wenig Sinn macht f\*ur dieses relativ
\*uberschaubare Probblem eine feinere Unterteilung zu w\*ahlen. So
entsteht ein kompaktes Modul mit einer einfachen Schnittstelle, welches
eine optimale Wiederverwehrtbarkeit gew\*ahrleistet. Die Klasse nennen
wir "vmMarch".

5.2 Die Schnittstelle

Die Schnittstelle unserer Klasse wird durch den public-Teil der
vmMarch-Klassendeklaration das Headerfile "vmMarch.h" definiert. Werfen
wir zun\*achst einen Blick hierauf.


class vmMarch
{
private:

...

public:
   // the constructors
   vmMarch(const char *dataName);
   vmMarch(const char *dataName, const int box[3][2]);
   vmMarch(vmData *dat);

   // the destructor
   ~vmMarch();

   // public member functions
   void SetThreshold(datavalue threshold);
   void SetBox(int box[3][2]);
   void SetCreaseAngle(float creaseAngle);
   void GetCreaseAngle(float *creaseAngle);
   void SetOutputFile(const char *fileName);
   void SetOutputFile(FILE *filePointer);

   void GetThreshold(datavalue *threshold);
   void GetBox(int box[3][2]);
   void GetDataDimension(int dataDim[3]);
   void GetBoxDimension(int boxDim[3]);
   void GetVoxelSize(float voxelSize[3]);

   void Apply(void);

};


Der private Teil soll uns zun\*achst nicht interessieren. Der
Konstruktor der Klasse kann mit drei verschiedenen
Parameterkombinationen aufgerufen werden. Die erste Variante kriegt nur
den Namen des Datenfiles, die zweite erhaelt noch eine 3D-Box hinzu,
als Hinweis fuer die vmData-Klasse nur diesen Teil zu laden. Die dritte
Variante braucht nur einen Pointer auf eine bereits erzeugte
vmData-Klasse. Der Destruktor gibt im wesentlichen allozierten
Speicherplatz wieder frei.

Die n\*achste Funktionsgruppe dient zum Einstellen bzw. Abfragen der
Parameter Schwellwert, Bereich, Winkel f\*ur harte Kanten,
Output-Filename, Gr\*o\*se des Datensatzes und der Voxel. Auf alle
Parameter kann ausschlie\*slich \*uber dieses prozedurale Interface
zugegriffen werden, da sich die entsprechenden Daten im private-Teil
der Klasse befinden. Dies hat zum einen den Vorteil erh\*oter
Sicherheit, da nicht ohne weiteres einfach ein Parameter
\*uberschrieben werden kann und zum anderen ist es m\*oglich die
internen Datenstrukturen zu ver\*andern, ohne da\*s sich die
Schnittstelle dabei ver\*andert.

Die Funktion Apply() startet, entsprechend der eingestellten Parameter,
den eigentlichen Marching-Vorgang.

5.3 Die Funktionen

Die Funktionen zur Realisierung des prozeduralen Interfaces sind
selbsterkl\*arend und hier nicht weiter besprochen. Der eigentliche
Marching Cubes Algorithmus verbirgt sich hinter folgenden Routinen:

Apply()

Initialisiert die Variablen mit Startwerten und l\*adt die Slices in
den Hauptspeicher. In ihr ist auch die Hauptiterationsschleife
enthalten, die das eigentliche Marching realisiert. Weiter berechnet
sie unter Zuhilfenahme von IsIn() den Tabellenindex und ruft im Falle
einer Intersektion die Routine TriangulateVoxel() auf. Nach Beendigung
der Iterationsschleife wird zun\*achst der Caching-Speicher wieder
freigegeben und dann das berechntet Dreiecksgitternetz auf Platte
geschrieben.

TriangulateVoxel()

Legt entsprechend der Tabelle die Dreiecke in des Voxel. Hierbei wird
ber\*ucksichtigt, ob die Vertices mittels der Funktion
CalcVoxelIntersect() neu berechnet werden m\*ussen, oder, ob sie aus dem
Cache genommen werden k\*onnen.

CalcVoxelIntersect()

Berechnet den neuen Vertex durch lineare Interpolation.

IsIn()

Ist in der jetztigen Implentierung als inline-Funktion ausgelegt und
liefert TRUE zur\*uck, falls der Wert innerhalb des gew\*unschten
K\*orpers liegt. Liegt der Wert au\*serhalb, gibt sie FALSE zur\*uck.

5.4 Automatische Generierung der Tabelle

Lutz

5.5 Testumgebung

Als Benutzerschnittstelle haben wir ein Kommandozeilen-Interface
implementiert. Der Modulname hierf\*ur ist "march.C". Es werden hier im
wesentlichen die Parameter \*uberpr\*uft und gesetzt. Danach wird durch
vmMarch::Apply() der March-Vorgang gestartet. Eine Bedienungsanleitung
befindet sich am Ende dieses Textes.


6. Vergleich mit der von Lorensen/Cline beschrieben Methode
-----------------------------------------------------------

Im wesentlichen haben wir uns an die in dem Paper von Lorensen und
Cline beschriebene Methode gehalten. Die Koh\*arenz-Ausnutzung haben
wir aufgrund der heutzutage meist gr\*o\*seren Hauptspeicher etwas
verbessert. Den Aufwand, der hierf\*ur getrieben werden mu\*s, haben
wir zulasten geringf\*ugig gesteigerten Speicherbedarfs reduziert. Der
wesentliche Unterschied unserer Implementierung betrifft die Tabelle,
die in dem Paper nur die 15 Grundf\*alle enth\*alt. Der Aufwand, der
getrieben werden mu\*s, um vom Tabellenindex (0 - 255) \*uber die 15
Grundf\*alle auf die tats\*achlichen Dreicke zu kommen, kann unter
Umst\*anden in der Summe (mehrere 100.000 mal) unn\*otig viel Zeit in
Anspruch nehemen. Wir haben die Tabelle \*ur alle 256 F\*alle erweitert
und kommen so direkt \*uber den Index zu den Dreiecken.


7. Beurteilung der Ergebnisse
-----------------------------

Nach anf\*anglichen Schwierigkeiten mit L\*ochern in den erzeugten
Oberfl\*achen, konnten wir diese nach genauem \*Uberpr\*ufen der Tabelle
beseitigen. Die Oberfl\*achen scheinen jetzt, zumindest bei den uns zur
Verf\*ugung stehenden Datens\*atzen korrekt zu sein.

Die Performance des Algorithmus ist sehr \*Uberzeugend. Reden Lorensen
und Cline in ihrem Paper f\*ur einen Datensatz mittlerer Gr\*o\*se noch
von Zeiten je nach Workstation zwischen 3 und 30 Minuten, so liegen bei
uns die Zeiten f\*uer einen Datensatz gleicher Gr\*o\*se weit unter
einer Minute. Den Gr\*o\*sten Anteil am Performancegewinn sicherlich
die moderneren Workstations haben.

Performance Daten (inklusive Laden der Daten von Platte)

Dimension          R3000/33MHz   R4000/100Mhz
 50 x  50 x  50    1.0s          0.4s
128 x 128 x 128    43s           18s
256 x 256 x 256
512 x 512 x 512


8. Bedienungsanleitung
----------------------

Das Testprogramm hat folgende Usage:

usage: march <datafile> <threshold> <creasangle>
             [<x_start x_end y_start y_end z_start z_end>]

Die drei ersten Parameter sind obligatorisch und haben folgende
Bedeutung:

datafile - Name des Datenfiles

threshold - Schwellwert f\*ur die innen/au\*sen Entscheidung

creaseangle - Winkel in Grad ab dem harte Kanten enstehen.
              Bei Eingabe von 0 werden keine Normalen berechnet.

Die letzten 6 Parameter sind optional und definieren eine 3D-Box im
Datensatz. Hierf\*ur werden C Array Koneventionen verwendet.

