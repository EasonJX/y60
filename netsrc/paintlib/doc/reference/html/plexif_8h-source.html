<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>paintlib: plexif.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a></div>
<h1>plexif.h</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment">/--------------------------------------------------------------------</span>
00003 <span class="comment">|</span>
00004 <span class="comment">|      $Id: plexif_8h-source.html,v 1.4 2004/09/15 15:26:29 uzadow Exp $</span>
00005 <span class="comment">|</span>
00006 <span class="comment">|      Copyright (c) 1996-2003 Ulrich von Zadow</span>
00007 <span class="comment">|</span>
00008 <span class="comment">|      Implementation of PLExif class by Mike Franklin</span>
00009 <span class="comment">|      Much of the decoding code was adapted from code by Ken Reneris:</span>
00010 <span class="comment">|         http://www.reneris.com/tools/exif.asp -</span>
00011 <span class="comment">|                                 though it has been heavily modified!</span>
00012 <span class="comment">|</span>
00013 <span class="comment">|</span>
00014 <span class="comment">\--------------------------------------------------------------------</span>
00015 <span class="comment">*/</span>
00016 
00017 <span class="preprocessor">#ifndef INCL_PLEXIF</span>
00018 <span class="preprocessor"></span><span class="preprocessor">#define INCL_PLEXIF</span>
00019 <span class="preprocessor"></span>
00020 <span class="preprocessor">#ifdef _MSC_VER                 // The microsoft compiler generates masses </span>
00021 <span class="preprocessor"></span>                                <span class="comment">// of symbol too long</span>
00022 <span class="preprocessor">#pragma warning(disable: 4786)  // for debugger warnings for sets and maps</span>
00023 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00024 <span class="preprocessor"></span>
00025 <span class="preprocessor">#include "<a class="code" href="plpaintlibdefs_8h.html">plpaintlibdefs.h</a>"</span>
00026 <span class="preprocessor">#include "plcountedpointer.h"</span>
00027 
00028 <span class="preprocessor">#include &lt;cstdio&gt;</span>
00029 <span class="preprocessor">#include &lt;vector&gt;</span>
00030 <span class="preprocessor">#include &lt;string&gt;</span>
00031 <span class="preprocessor">#include &lt;map&gt;</span>
00032 
00033 <span class="keyword">struct </span>jpeg_decompress_struct;
00034 <span class="keyword">struct </span>jpeg_compress_struct;
00035 
00036 <span class="comment">// these structures are for internal use only</span>
00037 <span class="keyword">struct </span>_PLExifTranslator;
00038 <span class="keyword">struct </span>_PLExifTagValues;
00039 <span class="keyword">struct </span>_PLExifFormatter;
00040 
00041 <span class="keyword">class </span>PLExifTag;
00042 <span class="keyword">typedef</span> PLCountedPointer&lt;PLExifTag&gt;           PLExifTagCPtr;  <span class="comment">// PLExifTag counted pointer</span>
00043 <span class="keyword">typedef</span> std::vector&lt;PLExifTagCPtr&gt;            PLExifTagList;  <span class="comment">// vector of PLExifTag counted pointers</span>
00044 <span class="keyword">typedef</span> PLCountedArrayPointer&lt;PLBYTE&gt;         PLByteCPtr;     <span class="comment">// utility typedef</span>
00045 
00046 
00047 <span class="keyword">class </span>PLExif
00048 {
00049 <span class="keyword">public</span>:
00050                         PLExif();
00051                         ~PLExif();
00052                         <span class="comment">// default copying is safe</span>
00053 
00054                         <span class="comment">// reset the internal data</span>
00055   <span class="keywordtype">void</span>                  Clear();
00056 
00057   <span class="comment">// Access the raw EXIF data (just a copy of the EXIF header held in memory)</span>
00058   size_t                GetRawDataSize() <span class="keyword">const</span>;
00059   PLBYTE *              GetRawData();
00060   <span class="keyword">const</span> PLBYTE *        GetRawData() <span class="keyword">const</span>;
00061 
00062 <span class="comment">/*</span>
00063 <span class="comment">  // These are not EXIF comments and should probably be moved to PLBmpInfo</span>
00064 <span class="comment">  const std::string &amp;   GetComment() const;</span>
00065 <span class="comment">  const char *          GetCommmentCStr() const;</span>
00066 <span class="comment"></span>
00067 <span class="comment">  void                  SetComment(const std::string &amp;);</span>
00068 <span class="comment">  void                  SetComment(const char *);</span>
00069 <span class="comment">*/</span>
00070   <span class="comment">// Access to the Main, Sub and Manufacturer tags</span>
00071   <span class="comment">// also a single list that contains them all</span>
00072   <span class="keyword">const</span> PLExifTagList &amp; GetAllTags() <span class="keyword">const</span>;
00073   <span class="keyword">const</span> PLExifTagList &amp; GetMainTags() <span class="keyword">const</span>;
00074   <span class="keyword">const</span> PLExifTagList &amp; GetSubTags() <span class="keyword">const</span>;
00075   <span class="keyword">const</span> PLExifTagList &amp; GetManufacturerTags() <span class="keyword">const</span>;
00076 
00077   <span class="comment">// As above but returning a traditional C style array pointer</span>
00078   <span class="comment">// instead of an STL vector</span>
00079   <span class="comment">// It is an array of pointers to PLExifTag</span>
00080   <span class="keyword">const</span> PLExifTagCPtr * GetAllTagsC(size_t &amp; size) <span class="keyword">const</span>;
00081   <span class="keyword">const</span> PLExifTagCPtr * GetMainTagsC(size_t &amp; size) <span class="keyword">const</span>;
00082   <span class="keyword">const</span> PLExifTagCPtr * GetSubTagsC(size_t &amp; size) <span class="keyword">const</span>;
00083   <span class="keyword">const</span> PLExifTagCPtr * GetManufacturerTagsC(size_t &amp; size) <span class="keyword">const</span>;
00084 
00085 
00086   <span class="comment">// All the following functions give access to a tag given a tag shortname</span>
00087   <span class="comment">// they almost all return a pointer to the whole tag but mostly this</span>
00088   <span class="comment">// will just be used to check whether the tag was found by testing for</span>
00089   <span class="comment">// a NULL pointer. The useful data - the tag value is generally returned</span>
00090   <span class="comment">// by reference.</span>
00091   <span class="comment">//</span>
00092   <span class="comment">// duplicate copies of the functions allow efficient use whether</span>
00093   <span class="comment">// the source tag string is a std::string or a char *</span>
00094   <span class="comment">// All forms return a pointer to the found tag, 0 if not found</span>
00095 
00096   <span class="comment">// Just return the tag pointer</span>
00097   PLExifTag *           GetTag(<span class="keyword">const</span> <span class="keywordtype">char</span> * TagShortName) <span class="keyword">const</span>;
00098   PLExifTag *           GetTag(<span class="keyword">const</span> std::string &amp; TagShortName)<span class="keyword"> const</span>
00099 <span class="keyword">                        </span>{ <span class="keywordflow">return</span> GetTag(TagShortName.c_str()); }
00100 
00101   <span class="comment">// place the tag value into the Value string, format is basic</span>
00102   <span class="comment">// as stored in the raw EXIF data eg f4.0 is likely to be 40/10</span>
00103   PLExifTag *           GetTag(<span class="keyword">const</span> <span class="keywordtype">char</span> * TagShortName, std::string &amp; Value) <span class="keyword">const</span>;
00104   PLExifTag *           GetTag(<span class="keyword">const</span> std::string &amp; TagShortName, std::string &amp; Value)<span class="keyword"> const</span>
00105 <span class="keyword">                        </span>{ <span class="keywordflow">return</span> GetTag(TagShortName.c_str(), Value); }
00106 
00107   <span class="comment">// place the tag value in the Value string, format is common form</span>
00108   <span class="comment">// eg f4.0 is 4.0 rather than 40/10</span>
00109   PLExifTag *           GetTagCommon(<span class="keyword">const</span> <span class="keywordtype">char</span> * TagShortName, std::string &amp; Value) <span class="keyword">const</span>;
00110   PLExifTag *           GetTagCommon(<span class="keyword">const</span> std::string &amp; TagShortName, std::string &amp; Value)<span class="keyword"> const</span>
00111 <span class="keyword">                        </span>{ <span class="keywordflow">return</span> GetTagCommon(TagShortName.c_str(), Value); }
00112 
00113   <span class="comment">// place the tag value in the Value double where appropriate</span>
00114   <span class="comment">// eg 1.234m focus</span>
00115   PLExifTag *           GetTag(<span class="keyword">const</span> <span class="keywordtype">char</span> * TagShortName, <span class="keywordtype">double</span> &amp; Value) <span class="keyword">const</span>;
00116   PLExifTag *           GetTag(<span class="keyword">const</span> std::string &amp; TagShortName, <span class="keywordtype">double</span> &amp; Value)<span class="keyword"> const</span>
00117 <span class="keyword">                        </span>{ <span class="keywordflow">return</span> GetTag(TagShortName.c_str(), Value); }
00118 
00119   <span class="comment">// return tag value as a string (empty string if not found), format is basic</span>
00120   <span class="comment">// as stored in the raw EXIF data eg f4.0 is likely to be 40/10</span>
00121   std::string &amp;         TagStr(<span class="keyword">const</span> <span class="keywordtype">char</span> * TagShortName) <span class="keyword">const</span>;
00122   std::string &amp;         TagStr(<span class="keyword">const</span> std::string &amp; TagShortName)<span class="keyword"> const</span>
00123 <span class="keyword">                        </span>{ <span class="keywordflow">return</span> TagStr(TagShortName.c_str()); }
00124 
00125   <span class="comment">// return tag value as a string (empty string if not found)</span>
00126   <span class="comment">// format is common form eg f4.0 is 4.0 rather than 40/10</span>
00127   std::string &amp;         TagStrCommon(<span class="keyword">const</span> <span class="keywordtype">char</span> * TagShortName) <span class="keyword">const</span>;
00128   std::string &amp;         TagStrCommon(<span class="keyword">const</span> std::string &amp; TagShortName)<span class="keyword"> const</span>
00129 <span class="keyword">                        </span>{ <span class="keywordflow">return</span> TagStrCommon(TagShortName.c_str()); }
00130 
00131   <span class="comment">// C string return versions of TagStr and TagStrCommon</span>
00132 
00133   <span class="comment">// return tag value as a string (empty string if not found), format is basic</span>
00134   <span class="comment">// as stored in the raw EXIF data eg f4.0 is likely to be 40/10</span>
00135   <span class="keyword">const</span> <span class="keywordtype">char</span> *          TagCStr(<span class="keyword">const</span> <span class="keywordtype">char</span> * TagShortName) <span class="keyword">const</span>;
00136   <span class="keyword">const</span> <span class="keywordtype">char</span> *          TagCStr(<span class="keyword">const</span> std::string &amp; TagShortName)<span class="keyword"> const</span>
00137 <span class="keyword">                        </span>{ <span class="keywordflow">return</span> TagCStr(TagShortName.c_str()); }
00138 
00139   <span class="comment">// return tag value as a string (empty string if not found)</span>
00140   <span class="comment">// format is common form eg f4.0 is 4.0 rather than 40/10</span>
00141   <span class="keyword">const</span> <span class="keywordtype">char</span> *          TagCStrCommon(<span class="keyword">const</span> <span class="keywordtype">char</span> * TagShortName) <span class="keyword">const</span>;
00142   <span class="keyword">const</span> <span class="keywordtype">char</span> *          TagCStrCommon(<span class="keyword">const</span> std::string &amp; TagShortName)<span class="keyword"> const</span>
00143 <span class="keyword">                        </span>{ <span class="keywordflow">return</span> TagCStrCommon(TagShortName.c_str()); }
00144 
00145   <span class="comment">// These two methods are primarily intended for use only by the Paintlib encoders and decoders</span>
00146                         <span class="comment">// load data from cinfo - jpeg_save_markers must have been called first</span>
00147   <span class="keywordtype">void</span>                  ReadData(<span class="keyword">const</span> jpeg_decompress_struct * pcinfo);
00148 
00149                          <span class="comment">// write data to cinfo - after jpeg_start_compress</span>
00150   <span class="keywordtype">void</span>                  WriteData(jpeg_compress_struct * pcinfo);
00151 
00152 
00153 <span class="keyword">private</span>:
00154   <span class="keywordtype">void</span>                  decode();   <span class="comment">// do the actual decoding of the EXIF data</span>
00155 
00156   <span class="keywordtype">void</span>                  ReadIFD(<span class="keyword">const</span> _PLExifTagValues * Tags, <span class="keywordtype">char</span> * Prefix, PLExifTagList &amp; sectionList);
00157   <span class="keywordtype">void</span>                  ExpandBinaryTag(<span class="keyword">const</span> std::string &amp; Src, <span class="keyword">const</span> _PLExifTagValues *Tags, PLUINT Type, PLExifTagList &amp; sectionList);
00158   <span class="keywordtype">void</span>                  DecodeCanCustomFncs(<span class="keyword">const</span> PLExifTag &amp; rootTag, <span class="keyword">const</span> _PLExifTagValues *Tags, PLExifTagList &amp; sectionList);
00159 
00160   <span class="keywordtype">void</span>                  CopyTag(<span class="keyword">const</span> <span class="keywordtype">char</span> * Src, <span class="keyword">const</span> <span class="keywordtype">char</span> * Dst);
00161   <span class="keywordtype">void</span>                  SetTag(<span class="keyword">const</span> <span class="keywordtype">char</span> * Dst, <span class="keyword">const</span> <span class="keywordtype">char</span> * Value);
00162   <span class="keywordtype">void</span>                  SetTag(<span class="keyword">const</span> <span class="keywordtype">char</span> * Dst, <span class="keyword">const</span> std::string &amp; Value)
00163                         { SetTag(Dst, Value.c_str()); }
00164   <span class="keywordtype">void</span>                  AddTag(<span class="keyword">const</span> <span class="keywordtype">char</span> * Dst, <span class="keyword">const</span> <span class="keywordtype">char</span> * SrcTag, <span class="keyword">const</span> <span class="keywordtype">char</span> * Skip = NULL, <span class="keyword">const</span> <span class="keywordtype">char</span> * Sep = NULL);
00165   <span class="keywordtype">void</span>                  AddStr(<span class="keyword">const</span> <span class="keywordtype">char</span> * Dst, <span class="keyword">const</span> std::string &amp; SrcStr,  <span class="keyword">const</span> <span class="keywordtype">char</span> * Skip = NULL, <span class="keyword">const</span> <span class="keywordtype">char</span> * Sep = NULL);
00166   <span class="keywordtype">void</span>                  FormatRange(<span class="keywordtype">double</span> Low, <span class="keywordtype">double</span> High, std::string &amp; Str);
00167 
00168   <span class="comment">// these functions were originally designed to read from a file</span>
00169   <span class="comment">// they have been kept but are now "reading" from the vector m_Data</span>
00170   <span class="comment">// I may remove at least the first couple later</span>
00171   <span class="keywordtype">void</span>                  SetPos(size_t Pos);
00172   size_t                GetPos();
00173 
00174   PLWORD                GetU16();
00175   PLLONG                GetU32();
00176   <span class="keywordtype">void</span>                  Read(<span class="keywordtype">void</span> * Buffer, size_t Size);
00177 
00178 
00179 
00180 <span class="keyword">private</span>:
00181 
00182   PLByteCPtr          m_Data;
00183   size_t              m_DataSize;
00184 
00185   <span class="comment">// this should probably be moved to PLBmpInfo</span>
00186 <span class="comment">//  std::string         m_Comment;  // include comments even though they're not really EXIF</span>
00187 
00188   size_t              m_Pos;     <span class="comment">// offset into data (effectively index into m_Data</span>
00189   size_t              m_IdfOffset;
00190   <span class="keywordtype">bool</span>                m_Endian;
00191 
00192   PLExifTagList       m_AllTags;      <span class="comment">// Tags in the order found</span>
00193   PLExifTagList       m_MainTags;
00194   PLExifTagList       m_SubTags;
00195   PLExifTagList       m_ManufacturerTags;
00196 
00197   <span class="keyword">typedef</span> std::map&lt;std::string, PLExifTagCPtr&gt;  TagMap;
00198   TagMap              m_Tags;         <span class="comment">// tag look up for searching by short name</span>
00199 
00200 };
00201 
00202 
00203 <span class="keyword">class </span>PLExifTag
00204 {
00205 <span class="keyword">public</span>:
00206                   <span class="comment">// default copying is safe</span>
00207                   ~PLExifTag();
00208 
00209   <span class="comment">// C Interface - returning const char *</span>
00210   <span class="keyword">const</span> <span class="keywordtype">char</span> *          GetShortNameCStr() <span class="keyword">const</span>;
00211   <span class="keyword">const</span> <span class="keywordtype">char</span> *          GetDescriptionCStr() <span class="keyword">const</span>;
00212   <span class="comment">// Format is basic as stored in the raw EXIF data</span>
00213   <span class="comment">// eg f4.0 is likely to be 40/10</span>
00214   <span class="keyword">const</span> <span class="keywordtype">char</span> *          GetValueCStr() <span class="keyword">const</span>;
00215   <span class="comment">// format is common form eg f4.0 is 4.0 rather than 40/10</span>
00216   <span class="keyword">const</span> <span class="keywordtype">char</span> *          GetValueCommonCStr() <span class="keyword">const</span>;
00217 
00218   <span class="comment">// STL Interface - returning const string &amp;</span>
00219   <span class="keyword">const</span> std::string &amp;   GetShortName() <span class="keyword">const</span>;
00220   <span class="keyword">const</span> std::string     GetDescription() <span class="keyword">const</span>;
00221   <span class="comment">// Format is basic as stored in the raw EXIF data</span>
00222   <span class="comment">// eg f4.0 is likely to be 40/10</span>
00223   <span class="keyword">const</span> std::string &amp;   GetValue() <span class="keyword">const</span>;
00224   <span class="comment">// format is common form eg f4.0 is 4.0 rather than 40/10</span>
00225   <span class="keyword">const</span> std::string &amp;   GetValueCommon() <span class="keyword">const</span>;
00226 
00227 <span class="keyword">private</span>:
00228   <span class="comment">// render functions to convert from raw memory data</span>
00229   size_t          RenDef(PLBYTE * &amp; Buffer);
00230   size_t          RenUDef(PLBYTE * &amp; Buffer);
00231   size_t          RenUndef(PLBYTE * &amp; Buffer);
00232   size_t          RenStr(PLBYTE * &amp; Buffer);
00233   size_t          RenURat(PLBYTE * &amp; Buffer);
00234   size_t          RenRat(PLBYTE * &amp; Buffer);
00235 
00236   <span class="comment">// conversion to common values</span>
00237   <span class="keywordtype">void</span>            CnvRat(std::string &amp; result);   <span class="comment">// evaluate nominator/denominator</span>
00238   <span class="keywordtype">void</span>            CnvRatAp(std::string &amp; result); <span class="comment">// evaluate nominator/denominator for fstop</span>
00239   <span class="keywordtype">void</span>            CnvFrac(std::string &amp; result);  <span class="comment">// evaluate nominator/denominator if &gt; than 1</span>
00240   <span class="keywordtype">void</span>            CnvApexShutter(std::string &amp; result);
00241   <span class="keywordtype">void</span>            CnvApexAp(std::string &amp; result);
00242   <span class="keywordtype">void</span>            CnvCompCfg(std::string &amp; result);   <span class="comment">// component configuration</span>
00243   <span class="keywordtype">void</span>            CnvCanINo(std::string &amp; result);    <span class="comment">// decode canon image no</span>
00244   <span class="keywordtype">void</span>            CnvCanSNo(std::string &amp; result);    <span class="comment">// decode canon serial no</span>
00245   <span class="keywordtype">void</span>            CnvCanFlash(std::string &amp; result);  <span class="comment">// canon flash details</span>
00246   <span class="keywordtype">void</span>            CnvCanAFPnt(std::string &amp; result);  <span class="comment">// canon AF focus point used</span>
00247 
00248   <span class="comment">// friends to let them have access to the conversion and rendering</span>
00249   <span class="comment">// functions without having to make them public to the whole world</span>
00250   <span class="keyword">friend</span> <span class="keyword">struct </span>_PLExifTagValues;
00251   <span class="keyword">friend</span> <span class="keyword">struct </span>_PLExifFormatter;
00252 
00253 <span class="keyword">private</span>:
00254                   PLExifTag(PLUINT TagNo, PLUINT Format, PLUINT NoComp);    <span class="comment">// only ever created by friend PLExif</span>
00255 
00256   <span class="keywordtype">void</span>            CleanWorkingArea();   <span class="comment">// call after all decoding done to free mem buffer</span>
00257   <span class="keywordtype">void</span>            Swizzle();
00258   <span class="keywordtype">void</span>            Render();
00259   <span class="keywordtype">void</span>            DoTranslation();
00260   <span class="keywordtype">void</span>            Value(size_t Index);
00261   <span class="keywordtype">double</span>          GetDouble(size_t Index);
00262 
00263 
00264   <span class="keyword">const</span> _PLExifTagValues *   m_Tag;    <span class="comment">// The tag for this item - pointer to static data so copy safe</span>
00265   <span class="keyword">const</span> _PLExifFormatter *   m_Fmt;    <span class="comment">// The format type - pointer to static data so copy safe</span>
00266 
00267   std::string     m_ShortName;    <span class="comment">// Copy of the short name</span>
00268   std::string     m_Lookup;       <span class="comment">// Lowercase version of shortname</span>
00269 
00270   size_t          m_TagNo;        <span class="comment">// The tag no</span>
00271   size_t          m_Format;       <span class="comment">// Format of this item</span>
00272   size_t          m_NoComp;       <span class="comment">// Number of components</span>
00273   size_t          m_Size;         <span class="comment">// Total size of item</span>
00274   PLByteCPtr      m_Buffer;       <span class="comment">// Copy of the item's data</span>
00275   size_t          m_Pos;          <span class="comment">// Location of tag</span>
00276 
00277   <span class="comment">// The rendered value</span>
00278   std::string     m_Value;        <span class="comment">// In printable form</span>
00279   std::string     m_Common;       <span class="comment">// in printable common form</span>
00280   PLLONG          m_Num;          <span class="comment">// Numerator</span>
00281   PLLONG          m_Den;          <span class="comment">// Denominator</span>
00282   PLLONG          m_Int;          <span class="comment">// As int</span>
00283   PLUINT          m_UInt;         <span class="comment">// As unsigned int</span>
00284   <span class="keywordtype">double</span>          m_Double;       <span class="comment">// As double</span>
00285 
00286 <span class="keyword">private</span>:
00287   <span class="comment">// not too thrilled with this but I inherited it!</span>
00288   <span class="comment">// however it does avoid having to put stuff into</span>
00289   <span class="comment">// the public interface that only PLExif will need</span>
00290   <span class="comment">// and will not be needed by the library clients</span>
00291   <span class="keyword">friend</span> <span class="keyword">class </span>PLExif;
00292 
00293 <span class="keyword">private</span>:
00294   <span class="comment">// these need to be static members to have access to conversion and render functions</span>
00295   <span class="keyword">static</span> _PLExifTagValues   MainTags[];
00296   <span class="keyword">static</span> _PLExifTagValues   SubTags[];
00297   <span class="keyword">static</span> _PLExifTagValues   NikonTags[];
00298   <span class="keyword">static</span> _PLExifTagValues   Nikon2Tags[];
00299   <span class="keyword">static</span> _PLExifTagValues   OlympusTags[];
00300   <span class="keyword">static</span> _PLExifTagValues   CanonTags[];
00301   <span class="keyword">static</span> _PLExifTagValues   CanonSet1[];
00302   <span class="keyword">static</span> _PLExifTagValues   CanonSet2[];
00303   <span class="keyword">static</span> _PLExifTagValues   CanonCFn[];
00304   <span class="keyword">static</span> _PLExifTagValues   FujifilmTags[];
00305   <span class="keyword">static</span> _PLExifTagValues   CasioTags[];
00306   <span class="keyword">static</span> _PLExifFormatter   rgExifFormat[];
00307 };
00308 
00309 
00310 
00311 
00312 
00313 
00314 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Sep 13 16:16:40 2004 for paintlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.2 </small></address>
</body>
</html>
