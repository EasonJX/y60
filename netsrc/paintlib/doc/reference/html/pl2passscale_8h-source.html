<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>paintlib: pl2passscale.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a></div>
<h1>pl2passscale.h</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment">/--------------------------------------------------------------------</span>
00003 <span class="comment">|</span>
00004 <span class="comment">|      $Id: pl2passscale_8h-source.html,v 1.4 2004/09/15 15:26:24 uzadow Exp $</span>
00005 <span class="comment">|</span>
00006 <span class="comment">|      Copyright (c) 1996-2002 Ulrich von Zadow</span>
00007 <span class="comment">|</span>
00008 <span class="comment">\--------------------------------------------------------------------</span>
00009 <span class="comment">*/</span>
00010 
00011 <span class="preprocessor">#ifndef _2_PASS_SCALE_H_</span>
00012 <span class="preprocessor"></span><span class="preprocessor">#define _2_PASS_SCALE_H_</span>
00013 <span class="preprocessor"></span>
00014 <span class="preprocessor">#include "plcontribdefs.h"</span>
00015 <span class="preprocessor">#include "<a class="code" href="plpaintlibdefs_8h.html">plpaintlibdefs.h</a>"</span>
00016 
00017 <span class="preprocessor">#include &lt;math.h&gt;</span>
00018 
00019 <span class="comment">// Not every math.h defines this :-(.</span>
00020 <span class="preprocessor">#ifndef  min</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#define min(a, b)       ((a) &lt; (b) ? (a) : (b))</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#ifndef  max</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#define max(a, b)       ((a) &lt; (b) ? (b) : (a))</span>
00026 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00027 <span class="preprocessor"></span>
00028 <span class="keyword">typedef</span> <span class="keyword">struct</span>
00029 <span class="keyword"></span>{
00030    <span class="keywordtype">int</span> *Weights;     <span class="comment">// Normalized weights of neighboring pixels</span>
00031    <span class="keywordtype">int</span> Left,Right;   <span class="comment">// Bounds of source pixels window</span>
00032 } ContributionType;  <span class="comment">// Contirbution information for a single pixel</span>
00033 
00034 <span class="keyword">typedef</span> <span class="keyword">struct</span>
00035 <span class="keyword"></span>{
00036    ContributionType *ContribRow; <span class="comment">// Row (or column) of contribution weights</span>
00037    <span class="keywordtype">int</span> WindowSize,               <span class="comment">// Filter window size (of affecting source pixels)</span>
00038        LineLength;               <span class="comment">// Length of line (no. or rows / cols)</span>
00039 } LineContribType;               <span class="comment">// Contribution information for an entire line (row or column)</span>
00040 
00041 <span class="keyword">typedef</span> bool (*ProgressAndAbortCallBack)(PLBYTE bPercentComplete);
00042 
00043 <span class="keyword">class </span>CDataRGB_UBYTE
00044 {
00045 <span class="keyword">public</span>:
00046   <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> _DataType[3];
00047   <span class="keyword">typedef</span> _DataType* _RowType;
00048   <span class="keyword">class </span>_Accumulator {
00049   <span class="keyword">public</span>:
00050       _Accumulator ()
00051       {
00052         val [0] = val [1] = val [2] = 0;
00053       };
00054       <span class="keywordtype">void</span> Accumulate (<span class="keywordtype">int</span> Weight, _DataType &amp;value)
00055       {
00056         val [0] += (Weight * value [0]);
00057         val [1] += (Weight * value [1]);
00058         val [2] += (Weight * value [2]);
00059       };
00060       <span class="keywordtype">void</span> Store (_DataType &amp;value)
00061       {
00062         value [0] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) ((val [0] + 128)/256);
00063         value [1] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) ((val [1] + 128)/256);
00064         value [2] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) ((val [2] + 128)/256);
00065       };
00066       <span class="keywordtype">int</span> val [3];
00067   };
00068 };
00069 
00070 <span class="keyword">class </span>CDataRGBA_UBYTE {
00071 <span class="keyword">public</span>:
00072   <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> _DataType[4];
00073   <span class="keyword">typedef</span> _DataType* _RowType;
00074   <span class="keyword">class </span>_Accumulator {
00075   <span class="keyword">public</span>:
00076       _Accumulator ()
00077       {
00078         val [0] = val [1] = val [2] = val [3] = 0;
00079       };
00080       <span class="keywordtype">void</span> Accumulate (<span class="keywordtype">int</span> dWeight, _DataType &amp;value)
00081       {
00082         val [0] += (dWeight * (value [0]));
00083         val [1] += (dWeight * (value [1]));
00084         val [2] += (dWeight * (value [2]));
00085         val [3] += (dWeight * (value [3]));
00086       };
00087       <span class="keywordtype">void</span> Store (_DataType &amp;value)
00088       {
00089         value [0] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) ((val [0] + 128)/256);
00090         value [1] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) ((val [1] + 128)/256);
00091         value [2] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) ((val [2] + 128)/256);
00092         value [3] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) ((val [3] + 128)/256);
00093       };
00094       <span class="keywordtype">int</span> val [4];
00095   };
00096 };
00097 
00098 <span class="keyword">template</span> &lt;<span class="keyword">class</span> DataClass&gt;
00099 <span class="keyword">class </span>C2PassScale
00100 {
00101 <span class="keyword">public</span>:
00102     <span class="keyword">typedef</span> <span class="keyword">typename</span> DataClass::_DataType _DataType;
00103     <span class="keyword">typedef</span> <span class="keyword">typename</span> DataClass::_RowType _RowType;
00104 
00105     C2PassScale (<span class="keyword">const</span> PLContribDef&amp; ContribDef,
00106                  ProgressAndAbortCallBack callback = NULL)
00107         : m_Callback (callback), m_ContribDef (ContribDef)
00108     {};
00109 
00110     <span class="keyword">virtual</span> ~C2PassScale() {};
00111 
00112    _RowType * Scale (
00113         _RowType   *pOrigImage,
00114         PLUINT        uOrigWidth,
00115         PLUINT        uOrigHeight,
00116         _RowType   *pDstImage,
00117         PLUINT        uNewWidth,
00118         PLUINT        uNewHeight);
00119 
00120 <span class="keyword">private</span>:
00121 
00122     ProgressAndAbortCallBack    m_Callback;
00123     <span class="keywordtype">bool</span>                        m_bCanceled;
00124 
00125     LineContribType *AllocContributions (PLUINT uLineLength,
00126                                          PLUINT uWindowSize);
00127 
00128     <span class="keywordtype">void</span> FreeContributions (LineContribType * p);
00129 
00130     LineContribType *CalcContributions (PLUINT    uLineSize,
00131                                         PLUINT    uSrcSize,
00132                                         <span class="keywordtype">double</span>  dScale);
00133 
00134     <span class="keywordtype">void</span> ScaleRow (_RowType           *pSrc,
00135                    PLUINT                uSrcWidth,
00136                    _RowType           *pRes,
00137                    PLUINT                uResWidth,
00138                    PLUINT                uRow,
00139                    LineContribType    *Contrib);
00140 
00141     <span class="keywordtype">void</span> HorizScale (_RowType           *pSrc,
00142                      PLUINT                uSrcWidth,
00143                      PLUINT                uSrcHeight,
00144                      _RowType           *pDst,
00145                      PLUINT                uResWidth,
00146                      PLUINT                uResHeight);
00147 
00148     <span class="keywordtype">void</span> VertScale (_RowType           *pSrc,
00149                     PLUINT                uSrcWidth,
00150                     PLUINT                uSrcHeight,
00151                     _RowType           *pDst,
00152                     PLUINT                uResWidth,
00153                     PLUINT                uResHeight);
00154 
00155     <span class="keyword">const</span> PLContribDef&amp; m_ContribDef;
00156 };
00157 
00158 <span class="keyword">template</span> &lt;<span class="keyword">class</span> DataClass&gt;
00159 LineContribType *
00160 C2PassScale&lt;DataClass&gt;::AllocContributions (PLUINT uLineLength, PLUINT uWindowSize)
00161 {
00162     LineContribType *res = <span class="keyword">new</span> LineContribType;
00163         <span class="comment">// Init structure header</span>
00164     res-&gt;WindowSize = uWindowSize;
00165     res-&gt;LineLength = uLineLength;
00166         <span class="comment">// Allocate list of contributions</span>
00167     res-&gt;ContribRow = <span class="keyword">new</span> ContributionType[uLineLength];
00168     <span class="keywordflow">for</span> (PLUINT u = 0 ; u &lt; uLineLength ; u++)
00169     {
00170         <span class="comment">// Allocate contributions for every pixel</span>
00171         res-&gt;ContribRow[u].Weights = <span class="keyword">new</span> <span class="keywordtype">int</span>[uWindowSize];
00172     }
00173     <span class="keywordflow">return</span> res;
00174 }
00175 
00176 <span class="keyword">template</span> &lt;<span class="keyword">class</span> DataClass&gt;
00177 <span class="keywordtype">void</span>
00178 C2PassScale&lt;DataClass&gt;::FreeContributions (LineContribType * p)
00179 {
00180     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> u = 0; u &lt; p-&gt;LineLength; u++)
00181     {
00182         <span class="comment">// Free contribs for every pixel</span>
00183         <span class="keyword">delete</span> [] p-&gt;ContribRow[u].Weights;
00184     }
00185     <span class="keyword">delete</span> [] p-&gt;ContribRow;    <span class="comment">// Free list of pixels contribs</span>
00186     <span class="keyword">delete</span> p;                   <span class="comment">// Free contribs header</span>
00187 }
00188 
00189 <span class="keyword">template</span> &lt;<span class="keyword">class</span> DataClass&gt;
00190 LineContribType *
00191 C2PassScale&lt;DataClass&gt;::CalcContributions
00192     (PLUINT uLineSize, PLUINT uSrcSize, <span class="keywordtype">double</span> dScale)
00193 {
00194     <span class="keywordtype">double</span> dWidth;
00195     <span class="keywordtype">double</span> dFScale = 1.0;
00196     <span class="keywordtype">double</span> dFilterWidth = m_ContribDef.GetWidth();
00197 
00198     <span class="keywordflow">if</span> (dScale &lt; 1.0)
00199     {    <span class="comment">// Minification</span>
00200         dWidth = dFilterWidth / dScale;
00201         dFScale = dScale;
00202     }
00203     <span class="keywordflow">else</span>
00204     {    <span class="comment">// Magnification</span>
00205         dWidth= dFilterWidth;
00206     }
00207 
00208     <span class="comment">// Window size is the number of sampled pixels</span>
00209     <span class="keywordtype">int</span> iWindowSize = 2 * (<span class="keywordtype">int</span>)ceil(dWidth) + 1;
00210 
00211     <span class="comment">// Allocate a new line contributions strucutre</span>
00212     LineContribType *res = AllocContributions (uLineSize, iWindowSize);
00213 
00214     <span class="keywordflow">for</span> (PLUINT u = 0; u &lt; uLineSize; u++)
00215     {   <span class="comment">// Scan through line of contributions</span>
00216         <span class="keywordtype">double</span> dCenter = (u+0.5)/dScale-0.5;   <span class="comment">// Reverse mapping</span>
00217         <span class="comment">// Find the significant edge points that affect the pixel</span>
00218         <span class="keywordtype">int</span> iLeft = max (0, (<span class="keywordtype">int</span>)floor (dCenter - dWidth));
00219         <span class="keywordtype">int</span> iRight = min ((<span class="keywordtype">int</span>)ceil (dCenter + dWidth), <span class="keywordtype">int</span>(uSrcSize) - 1);
00220 
00221         <span class="comment">// Cut edge points to fit in filter window in case of spill-off</span>
00222         <span class="keywordflow">if</span> (iRight - iLeft + 1 &gt; iWindowSize)
00223         {
00224             <span class="keywordflow">if</span> (iLeft &lt; (int(uSrcSize) - 1 / 2))
00225             {
00226                 iLeft++;
00227             }
00228             <span class="keywordflow">else</span>
00229             {
00230                 iRight--;
00231             }
00232         }
00233   <span class="comment">//ets+++ adjusted ileft and iright values not stored in contrib array</span>
00234         res-&gt;ContribRow[u].Left = iLeft;
00235         res-&gt;ContribRow[u].Right = iRight;
00236   <span class="comment">//ets</span>
00237         <span class="keywordtype">int</span> dTotalWeight = 0;  <span class="comment">// Zero sum of weights</span>
00238         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iSrc = iLeft; iSrc &lt;= iRight; iSrc++)
00239         {   <span class="comment">// Calculate weights</span>
00240             <span class="keywordtype">int</span> CurWeight = int (dFScale * (m_ContribDef.Filter (dFScale * (dCenter - (<span class="keywordtype">double</span>)iSrc)))*256);
00241             res-&gt;ContribRow[u].Weights[iSrc-iLeft] = CurWeight;
00242             dTotalWeight += CurWeight;
00243         }
00244         PLASSERT (dTotalWeight &gt;= 0);   <span class="comment">// An error in the filter function can cause this</span>
00245         <span class="keywordtype">int</span> UsedWeight = 0;
00246         <span class="keywordflow">if</span> (dTotalWeight &gt; 0)
00247         {   <span class="comment">// Normalize weight of neighbouring points</span>
00248             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iSrc = iLeft; iSrc &lt; iRight; iSrc++)
00249             {   <span class="comment">// Normalize point</span>
00250               <span class="keywordtype">int</span> CurWeight = (res-&gt;ContribRow[u].Weights[iSrc-iLeft]*256)/dTotalWeight;
00251               res-&gt;ContribRow[u].Weights[iSrc-iLeft] = CurWeight;
00252               UsedWeight += CurWeight;
00253             }
00254             <span class="comment">// The last point gets everything that's left over so the sum is</span>
00255             <span class="comment">// always correct.</span>
00256             res-&gt;ContribRow[u].Weights[iRight-iLeft] = 256 - UsedWeight;
00257         }
00258    }
00259    <span class="keywordflow">return</span> res;
00260 }
00261 
00262 
00263 <span class="keyword">template</span> &lt;<span class="keyword">class</span> DataClass&gt;
00264 <span class="keywordtype">void</span>
00265 C2PassScale&lt;DataClass&gt;::ScaleRow (_RowType *pSrc, PLUINT uSrcWidth,
00266                                   _RowType *pRes, PLUINT uResWidth,
00267                                   PLUINT uRow, LineContribType *Contrib)
00268 {
00269     _DataType *pSrcRow = pSrc[uRow];
00270     _DataType *pDstRow = pRes[uRow];
00271     <span class="keywordflow">for</span> (PLUINT x = 0; x &lt; uResWidth; x++)
00272     {   <span class="comment">// Loop through row</span>
00273         <span class="keyword">typename</span> DataClass::_Accumulator a;
00274         <span class="keywordtype">int</span> iLeft = Contrib-&gt;ContribRow[x].Left;    <span class="comment">// Retrieve left boundries</span>
00275         <span class="keywordtype">int</span> iRight = Contrib-&gt;ContribRow[x].Right;  <span class="comment">// Retrieve right boundries</span>
00276         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = iLeft; i &lt;= iRight; i++)
00277         {   <span class="comment">// Scan between boundries</span>
00278             <span class="comment">// Accumulate weighted effect of each neighboring pixel</span>
00279             a .Accumulate (Contrib-&gt;ContribRow[x].Weights[i-iLeft], pSrcRow[i]);
00280         }
00281         a .Store (pDstRow [x]);
00282     }
00283 }
00284 
00285 <span class="keyword">template</span> &lt;<span class="keyword">class</span> DataClass&gt;
00286 <span class="keywordtype">void</span>
00287 C2PassScale&lt;DataClass&gt;::HorizScale (_RowType *pSrc, PLUINT uSrcWidth, PLUINT uSrcHeight,
00288                                     _RowType *pDst, PLUINT uResWidth, PLUINT uResHeight)
00289 {
00290     <span class="keywordflow">if</span> (uResWidth == uSrcWidth)
00291     { <span class="comment">// No scaling required, just copy</span>
00292       <span class="keywordflow">for</span> (PLUINT u = 0; u &lt; uResHeight; u++)
00293         memcpy (pDst[u], pSrc[u], <span class="keyword">sizeof</span> (_DataType) * uSrcWidth);
00294 
00295     }
00296     <span class="comment">// Allocate and calculate the contributions</span>
00297     LineContribType * Contrib;
00298     Contrib = CalcContributions (uResWidth, uSrcWidth,
00299                                  <span class="keywordtype">double</span>(uResWidth) / <span class="keywordtype">double</span>(uSrcWidth));
00300     <span class="keywordflow">for</span> (PLUINT u = 0; u &lt; uResHeight; u++)
00301     {   <span class="comment">// Step through rows</span>
00302         <span class="keywordflow">if</span> (NULL != m_Callback)
00303         {
00304             <span class="comment">//</span>
00305             <span class="comment">// Progress and report callback supplied</span>
00306             <span class="comment">//</span>
00307             <span class="keywordflow">if</span> (!m_Callback (PLBYTE(<span class="keywordtype">double</span>(u) / <span class="keywordtype">double</span> (uResHeight) * 50.0)))
00308             {
00309                 <span class="comment">//</span>
00310                 <span class="comment">// User wished to abort now</span>
00311                 <span class="comment">//</span>
00312                 m_bCanceled = <span class="keyword">true</span>;
00313                 FreeContributions (Contrib);  <span class="comment">// Free contributions structure</span>
00314                 <span class="keywordflow">return</span>;
00315             }
00316         }
00317 
00318         ScaleRow (  pSrc,
00319                     uSrcWidth,
00320                     pDst,
00321                     uResWidth,
00322                     u,
00323                     Contrib);    <span class="comment">// Scale each row</span>
00324     }
00325     FreeContributions (Contrib);  <span class="comment">// Free contributions structure</span>
00326 }
00327 
00328 
00329 <span class="keyword">template</span> &lt;<span class="keyword">class</span> DataClass&gt;
00330 <span class="keywordtype">void</span>
00331 C2PassScale&lt;DataClass&gt;::VertScale (_RowType *pSrc, PLUINT uSrcWidth, PLUINT uSrcHeight,
00332                                    _RowType *pDst, PLUINT uResWidth, PLUINT uResHeight)
00333 {
00334     PLUINT u;
00335 
00336     <span class="keywordflow">if</span> (uSrcHeight == uResHeight)
00337     {   <span class="comment">// No scaling required, just copy</span>
00338       <span class="keywordflow">for</span> (u = 0; u &lt; uResHeight; u++)
00339         memcpy (pDst[u], pSrc[u], <span class="keyword">sizeof</span> (_DataType) * uSrcWidth);
00340     }
00341     <span class="comment">// Allocate and calculate the contributions</span>
00342     LineContribType * Contrib = CalcContributions (uResHeight, uSrcHeight, <span class="keywordtype">double</span>(uResHeight) / <span class="keywordtype">double</span>(uSrcHeight));
00343     <span class="keywordflow">for</span> (PLUINT y = 0; y &lt; uResHeight; y++)
00344     {    <span class="comment">// Loop through column</span>
00345         <span class="keywordflow">if</span> (NULL != m_Callback)
00346         {
00347             <span class="comment">//</span>
00348             <span class="comment">// Progress and report callback supplied</span>
00349             <span class="comment">//</span>
00350             <span class="keywordflow">if</span> (!m_Callback (PLBYTE(<span class="keywordtype">double</span>(y) / <span class="keywordtype">double</span> (uResHeight) * 50.0) + 50))
00351             {
00352                 <span class="comment">//</span>
00353                 <span class="comment">// User wished to abort now</span>
00354                 <span class="comment">//</span>
00355                 m_bCanceled = <span class="keyword">true</span>;
00356                 FreeContributions (Contrib);  <span class="comment">// Free contributions structure</span>
00357                 <span class="keywordflow">return</span>;
00358             }
00359         }
00360         <span class="keywordflow">for</span> (u = 0; u &lt; uResWidth; u++)
00361         {   <span class="comment">// Step through columns</span>
00362             <span class="keyword">typename</span> DataClass::_Accumulator a;
00363             <span class="keywordtype">int</span> iLeft = Contrib-&gt;ContribRow[y].Left;    <span class="comment">// Retrieve left boundries</span>
00364             <span class="keywordtype">int</span> iRight = Contrib-&gt;ContribRow[y].Right;  <span class="comment">// Retrieve right boundries</span>
00365             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = iLeft; i &lt;= iRight; i++)
00366             {   <span class="comment">// Scan between boundries</span>
00367                 <span class="comment">// Accumulate weighted effect of each neighboring pixel</span>
00368                 a.Accumulate (Contrib-&gt;ContribRow[y].Weights[i-iLeft], pSrc[i][u]);
00369             }
00370             a .Store (pDst[y][u]);
00371         }
00372 
00373     }
00374     FreeContributions (Contrib);     <span class="comment">// Free contributions structure</span>
00375 }
00376 
00377 
00378 <span class="keyword">template</span> &lt;<span class="keyword">class</span> DataClass&gt;
00379 <span class="keyword">typename</span> C2PassScale&lt;DataClass&gt;::_RowType *
00380 C2PassScale&lt;DataClass&gt;::Scale (_RowType *pOrigImage, PLUINT uOrigWidth, PLUINT uOrigHeight,
00381                                _RowType *pDstImage, PLUINT uNewWidth, PLUINT uNewHeight)
00382 {
00383     <span class="comment">// Scale source image horizontally into temporary image</span>
00384     m_bCanceled = <span class="keyword">false</span>;
00385     PLUINT u;
00386 
00387     <span class="comment">// Allocate temp image</span>
00388     _RowType *pTemp = <span class="keyword">new</span> _RowType[uOrigHeight];
00389     <span class="keywordflow">for</span> (u = 0; u &lt; uOrigHeight; u++)
00390       pTemp[u] = <span class="keyword">new</span> _DataType[uNewWidth];
00391 
00392     HorizScale (pOrigImage,
00393                 uOrigWidth,
00394                 uOrigHeight,
00395                 pTemp,
00396                 uNewWidth,
00397                 uOrigHeight);
00398     <span class="keywordflow">if</span> (m_bCanceled)
00399     {
00400       <span class="keywordflow">for</span> (u = 0; u &lt; uOrigHeight; u++)
00401         <span class="keyword">delete</span> [] pTemp[u];
00402       <span class="keyword">delete</span> [] pTemp;
00403       <span class="keywordflow">return</span> NULL;
00404     }
00405 
00406     <span class="comment">// Scale temporary image vertically into result image</span>
00407     VertScale ( pTemp,
00408                 uNewWidth,
00409                 uOrigHeight,
00410                 pDstImage,
00411                 uNewWidth,
00412                 uNewHeight);
00413     <span class="keywordflow">for</span> (u = 0; u &lt; uOrigHeight; u++)
00414       <span class="keyword">delete</span> [] pTemp[u];
00415     <span class="keyword">delete</span> [] pTemp;
00416     <span class="keywordflow">if</span> (m_bCanceled)
00417     {
00418         <span class="keywordflow">return</span> NULL;
00419     }
00420     <span class="keywordflow">return</span> pDstImage;
00421 }
00422 
00423 
00424 <span class="preprocessor">#endif //   _2_PASS_SCALE_H_</span>
00425 <span class="preprocessor"></span>
00426 <span class="comment">/*</span>
00427 <span class="comment">/--------------------------------------------------------------------</span>
00428 <span class="comment">|</span>
00429 <span class="comment">|      $Log: pl2passscale_8h-source.html,v $
00429 <span class="comment">|      Revision 1.4  2004/09/15 15:26:24  uzadow
00429 <span class="comment">|      Linux compatibility changes, doc update.
00429 <span class="comment">|</span>
00430 <span class="comment">|      Revision 1.9  2004/07/28 13:55:48  artcom</span>
00431 <span class="comment">|      Added 24 bpp support to plfilterresizebilinear.</span>
00432 <span class="comment">|</span>
00433 <span class="comment">|      Revision 1.8  2002/11/04 22:40:13  uzadow</span>
00434 <span class="comment">|      Updated for gcc 3.1</span>
00435 <span class="comment">|</span>
00436 <span class="comment">|      Revision 1.7  2002/02/24 13:00:45  uzadow</span>
00437 <span class="comment">|      Documentation update; removed buggy PLFilterRotate.</span>
00438 <span class="comment">|</span>
00439 <span class="comment">|      Revision 1.6  2001/10/06 22:03:26  uzadow</span>
00440 <span class="comment">|      Added PL prefix to basic data types.</span>
00441 <span class="comment">|</span>
00442 <span class="comment">|      Revision 1.5  2001/10/03 14:00:29  uzadow</span>
00443 <span class="comment">|      Much improved quality in FilterResizeBilinear.</span>
00444 <span class="comment">|</span>
00445 <span class="comment">|      Revision 1.4  2001/09/30 17:19:16  uzadow</span>
00446 <span class="comment">|      Removed lots of floating-point calculations.</span>
00447 <span class="comment">|</span>
00448 <span class="comment">|      Revision 1.3  2001/09/30 16:57:25  uzadow</span>
00449 <span class="comment">|      Improved speed of 2passfilter.h, code readability changes.</span>
00450 <span class="comment">|</span>
00451 <span class="comment">|      Revision 1.2  2001/09/16 20:57:17  uzadow</span>
00452 <span class="comment">|      Linux version name prefix changes</span>
00453 <span class="comment">|</span>
00454 <span class="comment">|      Revision 1.1  2001/09/16 19:03:23  uzadow</span>
00455 <span class="comment">|      Added global name prefix PL, changed most filenames.</span>
00456 <span class="comment">|</span>
00457 <span class="comment">|      Revision 1.8  2000/12/04 23:56:11  uzadow</span>
00458 <span class="comment">|      no message</span>
00459 <span class="comment">|</span>
00460 <span class="comment">|      Revision 1.7  2000/08/13 12:11:43  Administrator</span>
00461 <span class="comment">|      Added experimental DirectDraw-Support</span>
00462 <span class="comment">|</span>
00463 <span class="comment">|      Revision 1.6  2000/05/27 16:34:05  Ulrich von Zadow</span>
00464 <span class="comment">|      Linux compatibility changes</span>
00465 <span class="comment">|</span>
00466 <span class="comment">|      Revision 1.5  2000/01/16 20:43:15  anonymous</span>
00467 <span class="comment">|      Removed MFC dependencies</span>
00468 <span class="comment">|</span>
00469 <span class="comment">|      Revision 1.4  1999/12/31 17:55:08  Ulrich von Zadow</span>
00470 <span class="comment">|      Corrected rounding error.</span>
00471 <span class="comment">|</span>
00472 <span class="comment">|      Revision 1.3  1999/12/08 16:31:40  Ulrich von Zadow</span>
00473 <span class="comment">|      Unix compatibility</span>
00474 <span class="comment">|</span>
00475 <span class="comment">|      Revision 1.2  1999/10/22 21:21:34  Ulrich von Zadow</span>
00476 <span class="comment">|      no message</span>
00477 <span class="comment">|</span>
00478 <span class="comment">|      Revision 1.1  1999/10/21 16:05:17  Ulrich von Zadow</span>
00479 <span class="comment">|      Moved filters to separate directory. Added Crop, Grayscale and</span>
00480 <span class="comment">|      GetAlpha filters.</span>
00481 <span class="comment">|</span>
00482 <span class="comment">|      Revision 1.1  1999/10/19 21:29:55  Ulrich von Zadow</span>
00483 <span class="comment">|      Added filters.</span>
00484 <span class="comment">|</span>
00485 <span class="comment">|</span>
00486 <span class="comment">\--------------------------------------------------------------------</span>
00487 <span class="comment">*/</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Sep 13 16:16:40 2004 for paintlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.2 </small></address>
</body>
</html>
