<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>paintlib: pliff85.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a></div>
<h1>pliff85.h</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment">/--------------------------------------------------------------------</span>
00003 <span class="comment">|</span>
00004 <span class="comment">|      $Id: pliff85_8h-source.html,v 1.4 2004/09/15 15:26:29 uzadow Exp $</span>
00005 <span class="comment">|</span>
00006 <span class="comment">|      Defines structures and constants present in Electronic Arts IFF-85</span>
00007 <span class="comment">|      files, in particular those in ILBM and PBM files.</span>
00008 <span class="comment">|</span>
00009 <span class="comment">|       REFERENCES :</span>
00010 <span class="comment">|           Jerry Morrison, Electronic Arts; "EA IFF 85" Standard for</span>
00011 <span class="comment">|           Interchange Format Files; January 14, 1985</span>
00012 <span class="comment">|           Available from http://www.wotsit.org as iff.zip</span>
00013 <span class="comment">|</span>
00014 <span class="comment">|           Jerry Morrison, Electronic Arts; "ILBM" IFF Interleaved Bitmap;</span>
00015 <span class="comment">|           January 17, 1986</span>
00016 <span class="comment">|           Available from http://www.wotsit.org as ilbm.zip</span>
00017 <span class="comment">| </span>
00018 <span class="comment">|           Carolyn Scheppner - Commodore Amiga Technical Support;</span>
00019 <span class="comment">|           "Intro to Amiga IFF ILBM Files and Amiga Viewmodes";</span>
00020 <span class="comment">|           USENET posting to comp.graphics, comp.sys.amiga;</span>
00021 <span class="comment">|           August 25th, 1988</span>
00022 <span class="comment">| </span>
00023 <span class="comment">|      Rupert Welch (rafw@mindless.com) - December 2003</span>
00024 <span class="comment">|</span>
00025 <span class="comment">|      Copyright (c) 2003-2004 Ulrich von Zadow</span>
00026 <span class="comment">|</span>
00027 <span class="comment">\--------------------------------------------------------------------</span>
00028 <span class="comment">*/</span>
00029 
00030 <span class="preprocessor">#if !defined(INCL_PLIFF85)</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#define      INCL_PLIFF85</span>
00032 <span class="preprocessor"></span>
00033 <span class="preprocessor">#include "pldebug.h"</span>
00034 <span class="preprocessor">#include "<a class="code" href="plpaintlibdefs_8h.html">plpaintlibdefs.h</a>"</span>
00035 
00036 <span class="comment">// Standard IFF-85 constants and types.</span>
00037 <span class="keyword">namespace </span>PLIFF85
00038 {
00039   <span class="comment">// Standard IFF types based on their paintlib equivalents (where available).</span>
00040   <span class="comment">// This allows the stuff below to follow the documentation more closely.</span>
00041   <span class="keyword">typedef</span> PLBYTE          UBYTE;  <span class="comment">//&lt; 8-bit unsigned</span>
00042   <span class="keyword">typedef</span> <span class="keywordtype">signed</span> <span class="keywordtype">short</span>    WORD;   <span class="comment">//&lt; 16-bit signed</span>
00043   <span class="keyword">typedef</span> PLWORD          UWORD;  <span class="comment">//&lt; 16-bit unsigned</span>
00044   <span class="keyword">typedef</span> PLLONG          LONG;   <span class="comment">//&lt; 32-bit signed</span>
00045 
00046   <span class="keyword">typedef</span> LONG ID;        <span class="comment">//&lt; 4 chars in ' ' through '~'.</span>
00047 
00048   <span class="comment">// Chunks are the building blocks in the IFF structure.</span>
00049   <span class="keyword">struct </span>Chunk
00050   {
00051     ID      ckID;       <span class="comment">//&lt; Chunk ID</span>
00052     LONG    ckSize;     <span class="comment">//&lt; size of the chunk data following.</span>
00053     <span class="comment">// This is followed by ckSize UBYTEs.</span>
00054   };
00055 
00056   <span class="comment">// Converts a 4-character string to a IFF chunk ID format.</span>
00057   <span class="keyword">inline</span> ID MakeID(<span class="keyword">const</span> <span class="keywordtype">char</span> IDStr[4], <span class="keywordtype">bool</span> validate = <span class="keyword">true</span>)
00058   {
00059     <span class="keywordflow">if</span> (validate)
00060     {
00061       PLASSERT(IDStr[0] &gt;= <span class="charliteral">' '</span>);
00062       PLASSERT(IDStr[0] &lt;= <span class="charliteral">'~'</span>);
00063       PLASSERT(IDStr[1] &gt;= <span class="charliteral">' '</span>);
00064       PLASSERT(IDStr[1] &lt;= <span class="charliteral">'~'</span>);
00065       PLASSERT(IDStr[2] &gt;= <span class="charliteral">' '</span>);
00066       PLASSERT(IDStr[2] &lt;= <span class="charliteral">'~'</span>);
00067       PLASSERT(IDStr[3] &gt;= <span class="charliteral">' '</span>);
00068       PLASSERT(IDStr[3] &lt;= <span class="charliteral">'~'</span>);
00069     }
00070     <span class="keywordflow">return</span> ((UBYTE(IDStr[0]) &lt;&lt; 24) |
00071             (UBYTE(IDStr[1]) &lt;&lt; 16) |
00072             (UBYTE(IDStr[2]) &lt;&lt; 8) |
00073             (UBYTE(IDStr[3])));
00074   }
00075 
00076   <span class="keyword">const</span> ID ID_FORM    = MakeID(<span class="stringliteral">"FORM"</span>);   <span class="comment">//&lt; All valid IFF files should start with this.</span>
00077   <span class="keyword">const</span> ID ID_ILBM    = MakeID(<span class="stringliteral">"ILBM"</span>);   <span class="comment">//&lt; A ILBM image.</span>
00078   <span class="keyword">const</span> ID ID_PBM     = MakeID(<span class="stringliteral">"PBM "</span>);   <span class="comment">//&lt; A PBM image.</span>
00079   <span class="keyword">const</span> ID ID_BMHD    = MakeID(<span class="stringliteral">"BMHD"</span>);   <span class="comment">//&lt; Bitmap header.</span>
00080   <span class="keyword">const</span> ID ID_CMAP    = MakeID(<span class="stringliteral">"CMAP"</span>);   <span class="comment">//&lt; A colormap, or palette.</span>
00081   <span class="keyword">const</span> ID ID_CAMG    = MakeID(<span class="stringliteral">"CAMG"</span>);   <span class="comment">//&lt; Commodore AMiGa viewmodes.</span>
00082   <span class="keyword">const</span> ID ID_BODY    = MakeID(<span class="stringliteral">"BODY"</span>);   <span class="comment">//&lt; The body of the image.</span>
00083 
00084   <span class="comment">// BMHD types.</span>
00085 
00086   <span class="keyword">typedef</span> UBYTE Masking;  <span class="comment">//&lt; Choice of masking technique.</span>
00087 
00088   <span class="comment">// Designates an opaque rectangular image.</span>
00089   <span class="keyword">const</span> Masking mskNone                   = 0;
00090 
00091   <span class="comment">// \brief This means that a mask plane is interleaved with the bitplanes</span>
00092   <span class="comment">// in the BODY chunk.</span>
00093   <span class="keyword">const</span> Masking mskHasMask                = 1;
00094 
00095   <span class="comment">// \brief Indicates that pixels in the source planes matching</span>
00096   <span class="comment">// transparentColor are to be considered "transparent".</span>
00097   <span class="keyword">const</span> Masking mskHasTransparentColor    = 2;
00098 
00099   <span class="comment">// Indicates the reader may construct a mask by lassoing the image.</span>
00100   <span class="keyword">const</span> Masking mskLasso                  = 3;
00101 
00102   <span class="comment">// \brief Choice of compression algorithm applied to the rows of all</span>
00103   <span class="comment">// source and mask planes.</span>
00104   <span class="comment">// \note Do not compress across rows!</span>
00105   <span class="keyword">typedef</span> UBYTE Compression;
00106 
00107   <span class="keyword">const</span> Compression cmpNone       = 0;    <span class="comment">//&lt; No compression.</span>
00108 
00109   <span class="comment">// This is the byte run encoding described in Appendix C of the ILBM definition.</span>
00110   <span class="keyword">const</span> Compression cmpByteRun1   = 1;
00111 
00112   <span class="comment">// The required property "BMHD" holds a BitMapHeader as defined here.</span>
00113   <span class="comment">// It describes the dimensions and encoding of the image, including</span>
00114   <span class="comment">// data necessary to understand the BODY chunk to follow.</span>
00115   <span class="keyword">struct </span>BitMapHeader
00116   {
00117     UWORD       w;                      <span class="comment">//&lt; raster width in pixels.</span>
00118     UWORD       h;                      <span class="comment">//&lt; raster height in pixels.</span>
00119     WORD        x;                      <span class="comment">//&lt; pixel position for this image.</span>
00120     WORD        y;                      <span class="comment">//&lt; pixel position for this image.</span>
00121     UBYTE       nPlanes;                <span class="comment">//&lt; # source bitplanes</span>
00122     Masking     masking;                <span class="comment">//&lt; masking type.</span>
00123     Compression compression;            <span class="comment">//&lt; Compression type.</span>
00124     UBYTE       pad1;                   <span class="comment">//&lt; unused; for consistency, put 0 here.</span>
00125     UWORD       transparentColor;       <span class="comment">//&lt; transparent "color number" (sort of).</span>
00126     UBYTE       xAspect;                <span class="comment">//&lt; pixel aspect, a ratio width : height.</span>
00127     UBYTE       yAspect;                <span class="comment">//&lt; pixel aspect, a ratio width : height.</span>
00128     WORD        pageWidth;              <span class="comment">//&lt; source "page" size in pixels.</span>
00129     WORD        pageHeight;             <span class="comment">//&lt; source "page" size in pixels.</span>
00130   };
00131 
00132   <span class="comment">// The optional (but encouraged) property "CMAP" stores color map data</span>
00133   <span class="comment">// as triplets of red, green, and blue intensity values. The n color</span>
00134   <span class="comment">// map entries ("color registers") are stored in the order 0 through</span>
00135   <span class="comment">// n-1, totaling 3n bytes. Thus n is the ckSize/3. Normally, n would</span>
00136   <span class="comment">// equal 2 raised to the power of nPlanes.</span>
00137   <span class="comment">//</span>
00138   <span class="comment">// A CMAP chunk contains a ColorMap array as defined below. (These</span>
00139   <span class="comment">// typedefs assume a C compiler that implements packed arrays of</span>
00140   <span class="comment">// 3-byte elements.)</span>
00141   <span class="keyword">struct </span>ColorRegister
00142   {
00143     UBYTE red;                  <span class="comment">//&lt; red intensity 0..255.</span>
00144     UBYTE green;                <span class="comment">//&lt; green intensity 0..255.</span>
00145     UBYTE blue;                 <span class="comment">//&lt; blue intensity 0..255.</span>
00146   };
00147 
00148 <span class="comment">//  typedef ColorRegister ColorMap[n];  /* size = 3n bytes */</span>
00149 
00150   <span class="comment">// Commodore Amiga viewport mode.</span>
00151   <span class="keyword">typedef</span> LONG Viewmode;
00152 
00153   <span class="comment">// Viewmode masks.</span>
00154 
00155   <span class="comment">// Hold-and-Modify.  The bits in the two last planes describe an R G or B</span>
00156   <span class="comment">// modification to the color of the previous pixel on the line to create</span>
00157   <span class="comment">// the color of the current pixel.</span>
00158   <span class="keyword">const</span> Viewmode viewHAM    = 0x00000800;
00159 
00160 } <span class="comment">// namespace PLIFF85</span>
00161 
00162 <span class="preprocessor">#endif // !defined(INCL_PLIFF85)</span>
00163 <span class="preprocessor"></span>
00164 <span class="comment">/*</span>
00165 <span class="comment">/--------------------------------------------------------------------</span>
00166 <span class="comment">|</span>
00167 <span class="comment">|      $Log: pliff85_8h-source.html,v $
00167 <span class="comment">|      Revision 1.4  2004/09/15 15:26:29  uzadow
00167 <span class="comment">|      Linux compatibility changes, doc update.
00167 <span class="comment">|</span>
00168 <span class="comment">|      Revision 1.2  2004/04/16 20:14:41  uzadow</span>
00169 <span class="comment">|      Changes to make cdoc work.</span>
00170 <span class="comment">|</span>
00171 <span class="comment">|      Revision 1.1  2004/03/13 19:40:23  uzadow</span>
00172 <span class="comment">|      Added Rupert Welchs iff decoder.</span>
00173 <span class="comment">|</span>
00174 <span class="comment">|</span>
00175 <span class="comment">|</span>
00176 <span class="comment">\--------------------------------------------------------------------</span>
00177 <span class="comment">*/</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Sep 13 16:16:40 2004 for paintlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.2 </small></address>
</body>
</html>
